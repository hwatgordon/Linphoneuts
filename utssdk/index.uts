/**
 * Unified Telephony Service (UTS) cross-platform entrypoint.
 *
 * All methods delegate to a platform-specific implementation resolved at runtime.
 * Each method exposes a Promise-based API with normalized error objects and predictable
 * event dispatch semantics.
 */

declare const plus: any;
declare const uni: any;

type TransportKind = 'udp' | 'tcp' | 'tls';

type RegistrationState = 'none' | 'progress' | 'ok' | 'failed';

type CallState = 'incoming' | 'outgoing' | 'connected' | 'ended' | 'error';

type MessageEvent = 'received' | 'sent' | 'failed';

type AudioRoute = 'system' | 'earpiece' | 'speaker' | 'bluetooth';

type AudioRouteState = 'system' | 'earpiece' | 'speaker' | 'bluetooth' | 'unknown';

interface AudioDeviceSummary {
  id: string;
  name: string;
  type: AudioRouteState;
  selected: boolean;
}

interface DeviceEventPayload {
  devices: AudioDeviceSummary[];
  activeRoute?: AudioRouteState;
}

interface SipConfig {
  sipServer: string;
  username: string;
  password: string;
  transport?: TransportKind;
  displayName?: string;
}

interface MessagePayload {
  from?: string;
  to?: string;
  text: string;
}

interface NormalizedError {
  code: string;
  message: string;
}

interface PlatformEventMap {
  registration: { state: RegistrationState; detail?: any };
  call: { state: CallState; detail?: any };
  message: { event: MessageEvent; payload: MessagePayload };
  audioRoute: { route: AudioRouteState };
  device: DeviceEventPayload;
}

type PlatformEventName = keyof PlatformEventMap;

type PlatformEventHandler<K extends PlatformEventName> = (payload: PlatformEventMap[K]) => void;

interface PlatformShim {
  init(config: SipConfig): Promise<void>;
  register(): Promise<void>;
  unregister(): Promise<void>;
  getState(): Promise<Record<string, any>>;
  dispose(): Promise<void>;
  call: {
    dial(number: string): Promise<void>;
    hangup(): Promise<void>;
    answer(): Promise<void>;
    sendDtmf(tone: string): Promise<void>;
  };
  message: {
    send(to: string, text: string): Promise<void>;
  };
  audio: {
    setRoute(route: AudioRoute): Promise<void>;
  };
  subscribe<K extends PlatformEventName>(event: K, handler: PlatformEventHandler<K>): void;
  unsubscribe<K extends PlatformEventName>(event: K, handler: PlatformEventHandler<K>): void;
}

interface ListenerRegistry {
  registration: Set<(state: RegistrationState, detail?: any) => void>;
  call: Set<(state: CallState, detail?: any) => void>;
  message: Set<(event: MessageEvent, payload: MessagePayload) => void>;
  audioRoute: Set<(route: AudioRouteState) => void>;
  device: Set<(payload: DeviceEventPayload) => void>;
}

interface SubscriptionState {
  registration: boolean;
  call: boolean;
  message: boolean;
  audioRoute: boolean;
  device: boolean;
}

const GLOBAL_SHIM_REGISTRY = '__UTSSDK_PLATFORM_SHIMS__';

const listeners: ListenerRegistry = {
  registration: new Set(),
  call: new Set(),
  message: new Set(),
  audioRoute: new Set(),
  device: new Set()
};

const subscriptionState: SubscriptionState = {
  registration: false,
  call: false,
  message: false,
  audioRoute: false,
  device: false
};

const platformBridgeHandlers: {
  [K in PlatformEventName]: PlatformEventHandler<K>;
} = {
  registration(payload) {
    listeners.registration.forEach((handler) => {
      invokeListener(() => handler(payload.state, payload.detail));
    });
  },
  call(payload) {
    listeners.call.forEach((handler) => {
      invokeListener(() => handler(payload.state, payload.detail));
    });
  },
  message(payload) {
    listeners.message.forEach((handler) => {
      invokeListener(() => handler(payload.event, payload.payload));
    });
  },
  audioRoute(payload) {
    listeners.audioRoute.forEach((handler) => {
      invokeListener(() => handler(payload.route));
    });
  },
  device(payload) {
    listeners.device.forEach((handler) => {
      invokeListener(() => handler(payload));
    });
  }
};

type PlatformIdentifier = 'app-ios' | 'app-android' | 'web' | 'unknown';

let preferredAudioRoute: AudioRoute = 'system';

registerBuiltInPlatformShims();

const platformShim: PlatformShim = resolvePlatformShim();

function safeString(value: any, fallback: string): string {
  if (typeof value === 'string' && value.length > 0) {
    return value;
  }
  if (value === undefined || value === null) {
    return fallback;
  }
  try {
    return String(value);
  } catch (_) {
    return fallback;
  }
}

function normalizeError(error: any): NormalizedError {
  if (!error) {
    return { code: 'unknown', message: 'Unknown error' };
  }
  if (typeof error === 'string') {
    return { code: 'unknown', message: error };
  }
  if (typeof error === 'object') {
    const errObject = error as any;
    const code = safeString(errObject.code ?? errObject.errCode ?? errObject.errorCode, 'unknown');
    const message = safeString(errObject.message ?? errObject.errMsg ?? errObject.errorMessage, 'Unexpected platform error');
    return { code, message };
  }
  return { code: 'unknown', message: safeString(error, 'Unknown error') };
}

function invokeListener(fn: () => void): void {
  try {
    fn();
  } catch (error) {
    console.error('utssdk listener execution failed', error);
  }
}

function detectPlatform(): PlatformIdentifier {
  try {
    if (typeof plus !== 'undefined' && plus !== null && plus.os && typeof plus.os.name === 'string') {
      const osName = plus.os.name.toLowerCase();
      if (osName === 'android') {
        return 'app-android';
      }
      if (osName === 'ios') {
        return 'app-ios';
      }
      return 'unknown';
    }
  } catch (error) {
    console.warn('utssdk platform detection via plus failed', error);
  }

  try {
    const info = (uni as any).getSystemInfoSync?.();
    if (info && typeof info.platform === 'string') {
      const platform = info.platform.toLowerCase();
      if (platform === 'android') {
        return 'app-android';
      }
      if (platform === 'ios') {
        return 'app-ios';
      }
      if (platform === 'web' || platform === 'h5') {
        return 'web';
      }
    }
  } catch (error) {
    console.warn('utssdk platform detection via uni failed', error);
  }

  return 'unknown';
}

function resolvePlatformShim(): PlatformShim {
  const platform = detectPlatform();
  const shimFromRegistry = lookupPlatformShim(platform) ?? lookupPlatformShim('web') ?? lookupPlatformShim('unknown');
  if (shimFromRegistry) {
    return shimFromRegistry;
  }
  return createUnsupportedPlatformShim(platform);
}

function lookupPlatformShim(platform: PlatformIdentifier): PlatformShim | null {
  try {
    const globalRegistry = (globalThis as any)[GLOBAL_SHIM_REGISTRY];
    if (globalRegistry && platform in globalRegistry) {
      return globalRegistry[platform] as PlatformShim;
    }
  } catch (error) {
    console.warn('utssdk failed to read platform shim registry', error);
  }
  return null;
}

function createUnsupportedPlatformShim(platform: PlatformIdentifier): PlatformShim {
  const notSupported = async (): Promise<void> => {
    throw normalizeError({
      code: 'platform_unsupported',
      message: `UTS SDK is not available on platform: ${platform}`
    });
  };

  return {
    async init(_: SipConfig): Promise<void> {
      await notSupported();
    },
    async register(): Promise<void> {
      await notSupported();
    },
    async unregister(): Promise<void> {
      await notSupported();
    },
    async getState(): Promise<Record<string, any>> {
      await notSupported();
      return {};
    },
    async dispose(): Promise<void> {
      await notSupported();
    },
    call: {
      async dial(): Promise<void> {
        await notSupported();
      },
      async hangup(): Promise<void> {
        await notSupported();
      },
      async answer(): Promise<void> {
        await notSupported();
      },
      async sendDtmf(): Promise<void> {
        await notSupported();
      }
    },
    message: {
      async send(): Promise<void> {
        await notSupported();
      }
    },
    audio: {
      async setRoute(): Promise<void> {
        await notSupported();
      }
    },
    subscribe() {
      // No-op for unsupported platform.
    },
    unsubscribe() {
      // No-op for unsupported platform.
    }
  };
}

type NativeEventListener = (event: any, payload?: any) => void;

interface NormalizedNativeEvent {
  event: PlatformEventName;
  payload: PlatformEventMap[PlatformEventName];
}

function registerBuiltInPlatformShims(): void {
  try {
    const registry = ensureGlobalShimRegistry();
    if (!registry['app-ios']) {
      const iosShim = createIosPlatformShim();
      if (iosShim) {
        registry['app-ios'] = iosShim;
      }
    }
  } catch (error) {
    console.warn('utssdk failed to register built-in platform shims', error);
  }
}

function ensureGlobalShimRegistry(): Record<string, PlatformShim> {
  try {
    const globalRef = globalThis as any;
    if (!globalRef[GLOBAL_SHIM_REGISTRY]) {
      globalRef[GLOBAL_SHIM_REGISTRY] = {};
    }
    return globalRef[GLOBAL_SHIM_REGISTRY] as Record<string, PlatformShim>;
  } catch (error) {
    console.warn('utssdk unable to access global shim registry', error);
    return {};
  }
}

function createIosPlatformShim(): PlatformShim | null {
  const nativeBridge = tryCreateIosNativeBridge();
  if (!nativeBridge) {
    return null;
  }

  let cachedConfig: SipConfig | null = null;

  const observers: {
    [K in PlatformEventName]: Set<PlatformEventHandler<K>>;
  } = {
    registration: new Set(),
    call: new Set(),
    message: new Set(),
    audioRoute: new Set(),
    device: new Set()
  };

  const emitEvent = <K extends PlatformEventName>(event: K, payload: PlatformEventMap[K]): void => {
    observers[event].forEach((handler) => {
      invokeListener(() => handler(payload));
    });
  };

  attachIosEventListener(nativeBridge, (event, payload) => {
    const normalized = normalizeNativeEvent(event, payload);
    if (!normalized) {
      return;
    }
    emitEvent(normalized.event, normalized.payload);
  });

  const invoke = async (method: string, arg?: any): Promise<any> => {
    const fn = (nativeBridge as any)[method];
    if (typeof fn !== 'function') {
      throw normalizeError({ code: 'native_method_missing', message: `iOS bridge missing method: ${method}` });
    }
    try {
      const args = arg === undefined ? [] : [arg];
      const result = fn.apply(nativeBridge, args);
      if (result && typeof result.then === 'function') {
        return await result;
      }
      return result;
    } catch (error) {
      throw normalizeError(error);
    }
  };

  return {
    async init(config: SipConfig): Promise<void> {
      cachedConfig = { ...config };
      await invoke('initialize', toNativeConfig(config));
    },
    async register(): Promise<void> {
      await invoke('registerAccount', toNativeConfig(cachedConfig));
    },
    async unregister(): Promise<void> {
      await invoke('unregisterAccount');
    },
    async getState(): Promise<Record<string, any>> {
      const state = await invoke('getState');
      if (state && typeof state === 'object') {
        return state;
      }
      return {};
    },
    async dispose(): Promise<void> {
      await invoke('dispose');
    },
    call: {
      async dial(number: string): Promise<void> {
        await invoke('dial', { number });
      },
      async hangup(): Promise<void> {
        await invoke('hangup');
      },
      async answer(): Promise<void> {
        await invoke('answer');
      },
      async sendDtmf(tone: string): Promise<void> {
        await invoke('sendDtmf', { tone });
      }
    },
    message: {
      async send(to: string, text: string): Promise<void> {
        await invoke('sendMessage', { to, text });
      }
    },
    audio: {
      async setRoute(route: AudioRoute): Promise<void> {
        await invoke('setAudioRoute', { route });
      }
    },
    subscribe(event, handler) {
      observers[event].add(handler);
    },
    unsubscribe(event, handler) {
      observers[event].delete(handler);
    }
  };
}

function toNativeConfig(config: SipConfig | null): Record<string, any> {
  if (!config) {
    return {};
  }
  return {
    sipServer: safeString(config.sipServer, ''),
    username: safeString(config.username, ''),
    password: safeString(config.password, ''),
    displayName: safeString(config.displayName ?? '', ''),
    transport: config.transport ?? 'udp'
  };
}

function tryCreateIosNativeBridge(): any | null {
  const candidates = ['LinphoneSwiftBridge', 'linphoneSwiftBridge', 'UTSLinphoneBridge', 'LinphoneUTSBridge', 'UTSSDK'];
  for (const name of candidates) {
    try {
      const plugin = (uni as any)?.requireNativePlugin?.(name);
      if (plugin) {
        return plugin;
      }
    } catch (error) {
      // Continue to next candidate.
    }
  }
  try {
    const ios = (plus as any)?.ios;
    if (ios && typeof ios.importClass === 'function') {
      return ios.importClass('LinphoneSwiftBridge');
    }
  } catch (error) {
    // Silent fallback.
  }
  return null;
}

function attachIosEventListener(nativeBridge: any, listener: NativeEventListener): void {
  const setHandler = (nativeBridge as any)?.setEventHandler;
  if (typeof setHandler === 'function') {
    try {
      setHandler.call(nativeBridge, listener);
      return;
    } catch (error) {
      console.warn('utssdk ios shim failed to attach setEventHandler', error);
    }
  }

  const addEventListener = (nativeBridge as any)?.addEventListener;
  if (typeof addEventListener === 'function') {
    try {
      addEventListener.call(nativeBridge, 'event', (event: any) => {
        if (!event) {
          return;
        }
        const type = event.type ?? event.event ?? event.name ?? 'event';
        listener(type, event.payload ?? event.data ?? {});
      });
    } catch (error) {
      console.warn('utssdk ios shim failed to attach addEventListener', error);
    }
  }
}

function normalizeNativeEvent(event: any, payload: any): NormalizedNativeEvent | null {
  if (event == null && payload == null) {
    return null;
  }

  let eventName = '';
  if (typeof event === 'string') {
    eventName = event;
  } else if (event && typeof event === 'object') {
    eventName = safeString(event.type ?? event.event ?? event.name ?? event.kind, '');
    payload = event.payload ?? event.data ?? payload;
  }

  if (!eventName && payload && typeof payload === 'object' && typeof payload.type === 'string') {
    eventName = payload.type;
    payload = payload.payload ?? payload.data ?? payload;
  }

  const normalizedName = safeString(eventName, '').toLowerCase();

  switch (normalizedName) {
    case 'registration':
    case 'registration:state':
    case 'register':
      return { event: 'registration', payload: normalizeRegistrationEvent(payload) };
    case 'call':
    case 'call:state':
    case 'callstate':
      return { event: 'call', payload: normalizeCallEvent(payload) };
    case 'message':
    case 'message:event':
    case 'message:state':
      return { event: 'message', payload: normalizeMessageEvent(payload) };
    case 'audio':
    case 'audio:route':
    case 'call:audio-route':
    case 'audio-route':
      return { event: 'audioRoute', payload: normalizeAudioRouteEvent(payload) };
    case 'device':
    case 'device:audio':
    case 'audio:device':
    case 'devices':
    case 'audio-devices':
      return { event: 'device', payload: normalizeDeviceEvent(payload) };
    default:
      return null;
  }
}

function normalizeRegistrationEvent(payload: any): PlatformEventMap['registration'] {
  const detail = payload && typeof payload === 'object' ? payload : { value: payload };
  const stateSource = detail.state ?? detail.status ?? detail.code;
  const state = toRegistrationState(stateSource);
  return { state, detail };
}

function normalizeCallEvent(payload: any): PlatformEventMap['call'] {
  const detail = payload && typeof payload === 'object' ? payload : { value: payload };
  const state = toCallState(detail.state ?? detail.status ?? detail.code);
  return { state, detail };
}

function normalizeMessageEvent(payload: any): PlatformEventMap['message'] {
  const container = payload && typeof payload === 'object' ? payload : { text: payload };
  const event = toMessageEventKind(container.event ?? container.status ?? container.code);
  const messagePayload: MessagePayload = {
    from: safeString(container.from ?? container.sender ?? '', ''),
    to: safeString(container.to ?? container.recipient ?? '', ''),
    text: safeString(container.text ?? container.body ?? container.message ?? '', '')
  };
  return { event, payload: messagePayload };
}

function normalizeAudioRouteEvent(payload: any): PlatformEventMap['audioRoute'] {
  const routeSource = payload && typeof payload === 'object' ? payload.route ?? payload.name ?? payload.value : payload;
  const route = toAudioRouteStateValue(routeSource);
  return { route };
}

function normalizeDeviceEvent(payload: any): PlatformEventMap['device'] {
  const devicesSource = payload && typeof payload === 'object' ? payload.devices ?? payload.list ?? payload.items : payload;
  const devices = ensureArray(devicesSource)
    .map((item: any) => {
      if (!item || typeof item !== 'object') {
        return null;
      }
      const id = safeString(item.id ?? item.uid ?? item.identifier ?? item.name, '');
      const name = safeString(item.name ?? item.label ?? id, 'Unknown');
      const type = toAudioRouteStateValue(item.type ?? item.category ?? item.route ?? item.kind);
      const selected = Boolean(item.selected ?? item.active ?? item.default ?? item.isActive);
      if (!id && !name) {
        return null;
      }
      return {
        id: id || name,
        name,
        type,
        selected
      } as AudioDeviceSummary;
    })
    .filter((item): item is AudioDeviceSummary => !!item);

  const activeSource =
    (payload && typeof payload === 'object' && (payload.activeRoute ?? payload.active ?? payload.current)) ||
    devices.find((device) => device.selected)?.type;

  const activeRoute = activeSource ? toAudioRouteStateValue(activeSource) : undefined;

  return { devices, activeRoute };
}

function toRegistrationState(value: any): RegistrationState {
  const normalized = safeString(value, 'none').toLowerCase();
  if (normalized === 'ok' || normalized === 'connected' || normalized === 'success' || normalized === 'registered') {
    return 'ok';
  }
  if (normalized === 'progress' || normalized === 'progressing' || normalized === 'registering' || normalized === 'inprogress') {
    return 'progress';
  }
  if (normalized === 'failed' || normalized === 'error' || normalized === 'unregistered') {
    return 'failed';
  }
  return 'none';
}

function toCallState(value: any): CallState {
  const normalized = safeString(value, 'ended').toLowerCase();
  if (normalized === 'incoming' || normalized === 'ringing') {
    return 'incoming';
  }
  if (normalized === 'outgoing' || normalized === 'dialing' || normalized === 'calling') {
    return 'outgoing';
  }
  if (normalized === 'connected' || normalized === 'established' || normalized === 'answered') {
    return 'connected';
  }
  if (normalized === 'ended' || normalized === 'hangup' || normalized === 'terminated' || normalized === 'idle') {
    return 'ended';
  }
  return 'error';
}

function toMessageEventKind(value: any): MessageEvent {
  const normalized = safeString(value, 'received').toLowerCase();
  if (normalized === 'sent' || normalized === 'success') {
    return 'sent';
  }
  if (normalized === 'failed' || normalized === 'error') {
    return 'failed';
  }
  return 'received';
}

function toAudioRouteStateValue(value: any): AudioRouteState {
  const normalized = safeString(value, 'unknown').toLowerCase();
  if (normalized.includes('ear') || normalized === 'receiver') {
    return 'earpiece';
  }
  if (normalized.includes('speak')) {
    return 'speaker';
  }
  if (normalized.includes('blue')) {
    return 'bluetooth';
  }
  if (normalized === 'system' || normalized === 'default') {
    return 'system';
  }
  return 'unknown';
}

function ensureArray<T>(value: T | T[] | null | undefined): T[] {
  if (Array.isArray(value)) {
    return value;
  }
  if (value === undefined || value === null) {
    return [];
  }
  return [value];
}

function bindPlatformEvent<K extends PlatformEventName>(event: K): void {
  if (subscriptionState[event]) {
    return;
  }
  platformShim.subscribe(event, platformBridgeHandlers[event]);
  subscriptionState[event] = true;
}

function unbindPlatformEvent<K extends PlatformEventName>(event: K, registry: Set<any>): void {
  if (!subscriptionState[event]) {
    return;
  }
  if (registry.size > 0) {
    return;
  }
  platformShim.unsubscribe(event, platformBridgeHandlers[event]);
  subscriptionState[event] = false;
}

function ensureValidConfig(config: SipConfig): void {
  if (!config) {
    throw normalizeError({ code: 'invalid_config', message: 'Configuration is required.' });
  }
  if (!config.sipServer || !config.username || !config.password) {
    throw normalizeError({ code: 'invalid_config', message: 'sipServer, username, and password are mandatory.' });
  }
}

/**
 * Initializes the telephony stack with SIP credentials.
 * The call delegates to the active platform implementation; CallKit is not used.
 */
export async function init(config: SipConfig): Promise<void> {
  try {
    ensureValidConfig(config);
    await platformShim.init(config);
    preferredAudioRoute = 'system';
  } catch (error) {
    throw normalizeError(error);
  }
}

/**
 * Registers the SIP account on the active platform implementation.
 * CallKit is intentionally not involved in this process.
 */
export async function register(): Promise<void> {
  try {
    await platformShim.register();
  } catch (error) {
    throw normalizeError(error);
  }
}

/**
 * Unregisters the SIP account from the active platform implementation.
 */
export async function unregister(): Promise<void> {
  try {
    await platformShim.unregister();
  } catch (error) {
    throw normalizeError(error);
  }
}

export async function getState(): Promise<Record<string, any>> {
  try {
    return await platformShim.getState();
  } catch (error) {
    throw normalizeError(error);
  }
}

export async function dispose(): Promise<void> {
  try {
    await platformShim.dispose();
  } catch (error) {
    throw normalizeError(error);
  } finally {
    listeners.registration.clear();
    listeners.call.clear();
    listeners.message.clear();
    listeners.audioRoute.clear();
    listeners.device.clear();
    const events: PlatformEventName[] = ['registration', 'call', 'message', 'audioRoute', 'device'];
    events.forEach((event) => {
      if (subscriptionState[event]) {
        try {
          platformShim.unsubscribe(event, platformBridgeHandlers[event]);
        } catch (_) {
          // Ignore unsubscribe failures during dispose.
        }
        subscriptionState[event] = false;
      }
    });
    preferredAudioRoute = 'system';
  }
}

/**
 * Call control methods that are delegated to the platform shim.
 */
export const call = {
  /**
   * Initiates an outgoing call to the specified number.
   */
  async dial(number: string): Promise<void> {
    try {
      if (!number) {
        throw normalizeError({ code: 'invalid_number', message: 'The dialed number must not be empty.' });
      }
      await platformShim.call.dial(number);
    } catch (error) {
      throw normalizeError(error);
    }
  },

  /**
   * Terminates the current call session.
   */
  async hangup(): Promise<void> {
    try {
      await platformShim.call.hangup();
    } catch (error) {
      throw normalizeError(error);
    }
  },

  /**
   * Answers an incoming call.
   */
  async answer(): Promise<void> {
    try {
      await platformShim.call.answer();
    } catch (error) {
      throw normalizeError(error);
    }
  },

  /**
   * Sends a DTMF tone during an active call.
   */
  async sendDtmf(tone: string): Promise<void> {
    try {
      if (!tone) {
        throw normalizeError({ code: 'invalid_tone', message: 'DTMF tone must not be empty.' });
      }
      await platformShim.call.sendDtmf(tone);
    } catch (error) {
      throw normalizeError(error);
    }
  }
};

/**
 * Messaging helpers delegated to the platform shim.
 */
export const message = {
  /**
   * Sends an instant message using the underlying SIP stack.
   */
  async send(to: string, text: string): Promise<void> {
    try {
      if (!to) {
        throw normalizeError({ code: 'invalid_recipient', message: 'Recipient must not be empty.' });
      }
      if (!text) {
        throw normalizeError({ code: 'invalid_message', message: 'Message body must not be empty.' });
      }
      await platformShim.message.send(to, text);
    } catch (error) {
      throw normalizeError(error);
    }
  }
};

/**
 * Audio routing controls delegated to the platform shim.
 */
export const audio = {
  /**
   * Sets the audio route preference. When set to `system`, the OS default routing is restored.
   */
  async setRoute(route: AudioRoute): Promise<void> {
    try {
      if (preferredAudioRoute === route) {
        return;
      }
      preferredAudioRoute = route;
      await platformShim.audio.setRoute(route);
    } catch (error) {
      throw normalizeError(error);
    }
  }
};

/**
 * Subscribes to registration state changes emitted by the platform implementation.
 */
export function onRegistration(handler: (state: RegistrationState, detail?: any) => void): void {
  if (!handler) {
    return;
  }
  listeners.registration.add(handler);
  bindPlatformEvent('registration');
}

/**
 * Unsubscribes a registration listener.
 */
export function offRegistration(handler: (state: RegistrationState, detail?: any) => void): void {
  if (!handler) {
    return;
  }
  listeners.registration.delete(handler);
  unbindPlatformEvent('registration', listeners.registration);
}

/**
 * Subscribes to call state updates without involving CallKit APIs.
 */
export function onCall(handler: (state: CallState, detail?: any) => void): void {
  if (!handler) {
    return;
  }
  listeners.call.add(handler);
  bindPlatformEvent('call');
}

/**
 * Removes a call state listener.
 */
export function offCall(handler: (state: CallState, detail?: any) => void): void {
  if (!handler) {
    return;
  }
  listeners.call.delete(handler);
  unbindPlatformEvent('call', listeners.call);
}

/**
 * Subscribes to messaging events from the platform shim.
 */
export function onMessage(handler: (event: MessageEvent, payload: MessagePayload) => void): void {
  if (!handler) {
    return;
  }
  listeners.message.add(handler);
  bindPlatformEvent('message');
}

/**
 * Removes a messaging event listener.
 */
export function offMessage(handler: (event: MessageEvent, payload: MessagePayload) => void): void {
  if (!handler) {
    return;
  }
  listeners.message.delete(handler);
  unbindPlatformEvent('message', listeners.message);
}

/**
 * Subscribes to audio route notifications provided by the platform.
 */
export function onAudioRouteChanged(handler: (route: AudioRouteState) => void): void {
  if (!handler) {
    return;
  }
  listeners.audioRoute.add(handler);
  bindPlatformEvent('audioRoute');
}

/**
 * Removes an audio route listener.
 */
export function offAudioRouteChanged(handler: (route: AudioRouteState) => void): void {
  if (!handler) {
    return;
  }
  listeners.audioRoute.delete(handler);
  unbindPlatformEvent('audioRoute', listeners.audioRoute);
}

/**
 * Subscribes to audio device changes reported by the platform implementation.
 */
export function onDevicesChanged(handler: (payload: DeviceEventPayload) => void): void {
  if (!handler) {
    return;
  }
  listeners.device.add(handler);
  bindPlatformEvent('device');
}

/**
 * Unsubscribes an audio device listener.
 */
export function offDevicesChanged(handler: (payload: DeviceEventPayload) => void): void {
  if (!handler) {
    return;
  }
  listeners.device.delete(handler);
  unbindPlatformEvent('device', listeners.device);
}
